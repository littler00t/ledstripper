<html>
<head>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="pixi.js"></script>
<script type="text/javascript" src="codemirror.js"></script>
<script type="text/javascript" src="lua.js"></script>
<link rel="stylesheet" type="text/css" href="ledstrip.css" />
<link rel="stylesheet" href="codemirror.css">
<script type="text/javascript">

// global shared var with lua env
var led = null

$(document).ready(function(){
    var container = $('.ledstrip')[0];

    // create an new instance of a pixi stage
    var stage = new PIXI.Stage(0xFFFFFF, true);

    stage.setInteractive(false);

    var rwidth = 16;
    var rheight = 16;
    var rmarginx = 5;
    var rmarginy = 5;
    var marginleft = 10;
    var margintop = 10;
    var numperrow = 60;

    var numitems = 30;

    var canvasWidth = null;
    var canvasHeight = null;
    var renderer = null;

    function initCanvas() {
        console.log("initCanvas", numitems, numperrow, renderer == null);
        
        canvasWidth = ((numperrow+1)*(rwidth+rmarginx));
        canvasHeight = (Math.floor(numitems / numperrow)+1)*(rheight+rmarginy)+rmarginy*2;

        if(renderer == null) {
            renderer = PIXI.autoDetectRenderer(canvasWidth, canvasHeight);
        } else {
            renderer.resize(canvasWidth, canvasHeight);
        }

        renderer.view.style.width = canvasWidth + "px";
        renderer.view.style.height = canvasHeight + "px";

        // set the canvas width and height to fill the screen
        //renderer.view.style.width = window.innerWidth + "px";
        //renderer.view.style.height = window.innerHeight + "px";
        renderer.view.style.display = "block";

        // add render view to DOM
        container.appendChild(renderer.view);
    }
    
    var graphics = new PIXI.Graphics();

    function drawleds(frame) {
        
        var newframe = null;
        
        var numbytes = 0; 
        if(typeof frame == 'object' && frame.constructor === Array) {
            numbytes = frame.length;
            newframe = frame;
        } else {
            numbytes = numitems*3;
            newframe = Array(numbytes);
            // init to default value
            for(var i=0;i<numbytes;i++) {
                newframe[i] = 128;
            }
        }
        
        graphics.clear();

        for(var i=0;i<numitems;i++) {
            var rownum = Math.floor(i / numperrow);
            var topx = marginleft+(i % numperrow)*(rwidth+rmarginx);
            var topy = margintop+rownum*(margintop+rheight);

            graphics.lineStyle(1, 0x000000, 1);

            var bufferOffset = i*3;
            var color = (newframe[bufferOffset] << 16) | (newframe[bufferOffset+1] << 8) | (newframe[bufferOffset+2]);
            graphics.beginFill(color, 1);
            graphics.drawRect(topx, topy, rwidth, rheight);
            graphics.endFill();
        }
    }
    
    // initial drawing
    initCanvas();
    drawleds();
    stage.addChild(graphics);
    renderer.render(stage);

    led = {
        latch: function(frame) {
            drawleds(frame);
            renderer.render(stage);
        },
        setsize: function(pnumitems, pnumperrow) {
            console.log("setsize", pnumitems, pnumperrow);
            numitems = pnumitems;
            if(typeof pnumperrow == 'number') {
                numperrow = pnumperrow;
            }
            initCanvas();
        },
        debug: function(a) {
            // TODO - restore functionality
            // var debugcontainer = $("<div>&nbsp;</div>")[0];
            // $("#debugcontainer").append(debugcontainer);
            // var debugstrip = LEDstrip(debugcontainer, numleds);
            // for(var i=1;i<=numleds;i++) {
            //  var c = a.get(i);
            //  if(typeof c == 'undefined') {
            //      r = g = b = 0;
            //  } else {
            //      r = c.get(1);
            //      g = c.get(2);
            //      b = c.get(3);
            //  }
            //  debugstrip.pushrgb([r,g,b]);
            // }
            // debugstrip.latch();
        }
    }

    $('#diffuser').change(function(e) {
        $('.ledstrip').toggleClass('diffuse');
    });
    
    

});
</script>
</head>
<body>
       <header>
         <h1>LED Strip Simulator</h1>
       </header>
       <article>
         <div class="ledstrip"></div>
         <br />
         <form>
           <input type="checkbox" id="diffuser" value="0" /> <label for="diffuser">Diffuser</label>
         </form>
         <br/>
         <p>
           <button onclick="executeLua(myCodeMirror.getValue(), true); return false" id="execute">Execute</button>
           <button onclick="led.stopled()" id="stop">Stop</button>
         </p>
         <p>
         <textarea id="mytext">
-- This is lua!
print("this will go to console")
-- number of LEDs
-- param1: number of LEDs
-- param2: break after count (optional)
-- e.g. setstripsize(30,10) - show 3 rows with 10 elements each
setstripsize(30)
-- fps
setframerate(60)

-- define a init function 'init_animation' that takes the number of leds
-- define a function with the signature of 'frame' that returns frames (char sequence of byte color values)
-- call the startled function passing in the frame function to start simulator. init_animation will get called then.

---- paste animation here
--- example: scanner -- remove if you paste own animation
function init_animation(_buffer)
    color = {0, 255, 0}
    spread = 3
    direction = 1
    position = spread
    
    buffer = _buffer
    buffer:fill(0, 0, 0)
    
    j = 1
    for i = spread,1,-1 do
        r = math.floor(color[1] * ((spread + 1 - i) / (spread + 1)))
        g = math.floor(color[2] * ((spread + 1 - i) / (spread + 1)))
        b = math.floor(color[3] * ((spread + 1 - i) / (spread + 1)))
        buffer:set(j, r, g, b)
        j = j+1
    end
    buffer:set(j, color[1], color[2], color[3])
    for i = 1,spread do
        r = math.floor(color[1] * ((spread + 1 - i) / (spread + 1)))
        g = math.floor(color[2] * ((spread + 1 - i) / (spread + 1)))
        b = math.floor(color[3] * ((spread + 1 - i) / (spread + 1)))
        buffer:set(j, r, g, b)
        j = j+1
    end
end

function scanner()
    position = position + direction;

    if (position > (buffer:size() - spread)) then
        direction = -1
    end

    if (position < (1 + spread)) then
        direction = 1
    end

    buffer:shift(direction)
end

function frame(offset)
    scanner()
end
---- end example

-- start the animation
startled(frame)
         </textarea>
         <p>
           <h4>output</h4>
           <div id="debugcontainer"></div>
           <pre id="output"></pre>
         </p>
    </p>
    </article>

<script type="text/lua">

ws2812 = {}
ws2812.SHIFT_CIRCULAR = 1
ws2812.SHIFT_LOGICAL = 2
ws2812.FADE_IN = 1
ws2812.FADE_OUT = 2

Buffer = {}
Buffer.__index = Buffer

function Buffer.newBuffer(numberOfLeds, bytesPerLed)
   local buf = {}             -- our new object
   setmetatable(buf,Buffer)  -- make Account handle lookup
      
   buf.numberOfLeds = numberOfLeds
   buf.bytesPerLed = 3
   buf.bufferSize = buf.numberOfLeds*buf.bytesPerLed
   buf.buffer = {n=buf.bufferSize}
   for i = 1, buf.bufferSize do
     buf.buffer[i] = 0
   end
   
   return buf
end

function Buffer:get(index)
 print("get TODO")
end

function Buffer:set(index, g, r, b)
  if(index>self.numberOfLeds) then
    print("index too high", index)
  end
  if(index<1) then
    print("index too low", index)
  end
  if (type(g) == "table") then
    local ng = g[1]
    r = g[2]
    b = g[3]
    g = ng
  end
  local offset = (index-1)*self.bytesPerLed
  self.buffer[offset+1] = r
  self.buffer[offset+2] = g
  self.buffer[offset+3] = b
end
-- test code
--local buffer = Buffer.newBuffer(10,10)
--buffer:set(1, 255, 0, 0)
--buffer:set(1, {0, 0, 0, 255})
--buffer:set(1, string.char(255, 0, 0))

function Buffer:size()
  return self.numberOfLeds
end

function Buffer:fade(v, inourout)
  for i=1, #self.buffer do
    local newval = 0
    if inorout==ws2812.FADE_IN then
      self.buffer[i] = math.max(255, self.buffer[i] * v)
    else
      self.buffer[i] = self.buffer[i] / v
    end
  end
end

function Buffer:fill(r, g, b)
  local n = self:size()
  for i=1, n do
    self:set(i, r, g, b)
  end
end

-- SHIFT CIRCULAR
function Buffer:shift(value, mode)
  if value==nil then
    value = 1
  end
  -- if negative then take from left side
  local numtotake = math.abs(value)*3
  for i=1, numtotake do
    local takenout = 0
    if value<0 then
        -- remove first element
        takenout = table.remove(self.buffer, 1)
    else
        -- remove last element
        takenout = table.remove(self.buffer)
    end
    if mode==ws2812.SHIFT_LOGICAL then
        takenout = 0
    end
    if value<0 then
        -- remove first element --> insert at end
        table.insert(self.buffer, takenout)
    else
        -- remove last element --> insert at beginning
        table.insert(self.buffer, 1, takenout)
    end
  end
end

    -- frame rate (fps)
    framerate = 60
    function pushled (a)
        js.global.led:latch(js.global:Array(table.unpack(globalbuffer.buffer)))
        pushledFrameCount = pushledFrameCount + 1
    end
    function bytestostring(bytes)
      s = {}
      cnt = 1
      for i = 1, #bytes do
        for j = 1, 3 do
          s[cnt] = string.char(bytes[i][j])
          cnt = cnt +1
        end
      end
      return table.concat(s)
    end
    cnt = 0
    function stopled()
        window:clearInterval(js.global.led.interval)
    end
    js.global.led.stopled = stopled
    function startled(framegen)
        pushledFrameCount = 0
        delay = 1000/framerate
        stopled()
        globalbuffer = Buffer.newBuffer(numleds, 3)
        init_animation(globalbuffer)
        js.global.led.interval = window:setInterval(function() pushled(framegen()) end, delay)
    end
    function setstripsize(pnumleds, pbreakat)
        numleds = pnumleds
        breakat = pbreakat
        js.global.led:setsize(pnumleds, pbreakat)
    end
    function getstripsize()
        return numleds
    end
    -- needs to be set before startled
    function setframerate(newframerate)
        framerate = newframerate
    end
    function debugframe(frame)
        js.global.led:debug(frame)
    end
        
</script>

<script>
    // CodeMirror
    var myCodeMirror = CodeMirror.fromTextArea(document.getElementById('mytext'));
    //myCodeMirror.setSize(screen.width*0.6, screen.height*0.2);
    
    // Execution
    var outputElement = document.getElementById('output')
    var Module = {
      print: function(x) {
        outputElement.textContent = (outputElement.textContent ? outputElement.textContent + '\n' : '') + x;
      }
    };
    
    function executeLua(code, clear) {
      if (clear) {
        outputElement.style.color = null;
        outputElement.textContent = '';
      }
      try {
        L.execute(code);
      } catch(e) {
        outputElement.style.color = "red";
        outputElement.textContent = e.toString();
      }
    }
</script>
<script src="lua.vm.js"></script>
</body>
</html>
